<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="金汇移动开发团队" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="第一部分：前言一、为什么要使用 ES6ES6代表了未来，对未来理应拥抱。为从以下几个角度来看，ES6的推广势在必行：  解放开发效率  新特性的合理使用，优雅而简洁 减少第三方库的依赖 可维护性提升，代码量减少   面向未来。  向标准靠拢 官方支持 迟早要学   其他方面  提升技术先进性 促进技术交流，提高技术氛围 编程激情 整合部分历史代码的好机会    二、Nodejs各版本对应的ES6支">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 2015 语法分享">
<meta property="og:url" content="http://jhmobile.github.io/2017/10/11/ECMAScript-2015-语法分享/index.html">
<meta property="og:site_name" content="金汇移动开发团队">
<meta property="og:description" content="第一部分：前言一、为什么要使用 ES6ES6代表了未来，对未来理应拥抱。为从以下几个角度来看，ES6的推广势在必行：  解放开发效率  新特性的合理使用，优雅而简洁 减少第三方库的依赖 可维护性提升，代码量减少   面向未来。  向标准靠拢 官方支持 迟早要学   其他方面  提升技术先进性 促进技术交流，提高技术氛围 编程激情 整合部分历史代码的好机会    二、Nodejs各版本对应的ES6支">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yqfile.alicdn.com/f1ae6e19b5580b4f3a618e5351b74c55fd4beefb.jpeg">
<meta property="og:image" content="http://jhmobile.github.io/images/image1.png">
<meta property="og:updated_time" content="2017-10-11T09:21:14.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript 2015 语法分享">
<meta name="twitter:description" content="第一部分：前言一、为什么要使用 ES6ES6代表了未来，对未来理应拥抱。为从以下几个角度来看，ES6的推广势在必行：  解放开发效率  新特性的合理使用，优雅而简洁 减少第三方库的依赖 可维护性提升，代码量减少   面向未来。  向标准靠拢 官方支持 迟早要学   其他方面  提升技术先进性 促进技术交流，提高技术氛围 编程激情 整合部分历史代码的好机会    二、Nodejs各版本对应的ES6支">
<meta name="twitter:image" content="https://yqfile.alicdn.com/f1ae6e19b5580b4f3a618e5351b74c55fd4beefb.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jhmobile.github.io/2017/10/11/ECMAScript-2015-语法分享/">





  <title> ECMAScript 2015 语法分享 | 金汇移动开发团队 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">金汇移动开发团队</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-admin">
          <a href="/admin" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            管理
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://jhmobile.github.io/2017/10/11/ECMAScript-2015-语法分享/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jinhui-mobile">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金汇移动开发团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ECMAScript 2015 语法分享
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T15:53:09+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一部分：前言"><a href="#第一部分：前言" class="headerlink" title="第一部分：前言"></a>第一部分：前言</h1><h2 id="一、为什么要使用-ES6"><a href="#一、为什么要使用-ES6" class="headerlink" title="一、为什么要使用 ES6"></a>一、为什么要使用 ES6</h2><p>ES6代表了未来，对未来理应拥抱。为从以下几个角度来看，ES6的推广势在必行：</p>
<ul>
<li><p>解放开发效率</p>
<ul>
<li>新特性的合理使用，优雅而简洁</li>
<li>减少第三方库的依赖</li>
<li>可维护性提升，代码量减少</li>
</ul>
</li>
<li><p>面向未来。</p>
<ul>
<li>向标准靠拢</li>
<li>官方支持</li>
<li>迟早要学</li>
</ul>
</li>
<li><p>其他方面</p>
<ul>
<li>提升技术先进性</li>
<li>促进技术交流，提高技术氛围</li>
<li>编程激情</li>
<li>整合部分历史代码的好机会</li>
</ul>
</li>
</ul>
<h2 id="二、Nodejs各版本对应的ES6支持情况"><a href="#二、Nodejs各版本对应的ES6支持情况" class="headerlink" title="二、Nodejs各版本对应的ES6支持情况"></a>二、Nodejs各版本对应的ES6支持情况</h2><p>1、如果你想一览Node不同版本对所有ES6的特性支持情况，就可以参看<a href="http://node.green/" target="_blank" rel="external">node.green</a>这个网站</p>
<p>可以看到<br>6.11.2 - 99%<br>6.4.0 - 95%<br>5.12.0 - 59%</p>
<p>2、可以安转<code>es-checker</code>工具，通过该工具查看node支持的es6语法</p>
<pre><code>sudo npm install es-checker -g
</code></pre><h2 id="三、实用特性使用情况"><a href="#三、实用特性使用情况" class="headerlink" title="三、实用特性使用情况"></a>三、实用特性使用情况</h2><p><img src="https://yqfile.alicdn.com/f1ae6e19b5580b4f3a618e5351b74c55fd4beefb.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">推荐程度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">arrows</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">enhanced object literals</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">template strings</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">destructuring</td>
<td style="text-align:center">★★</td>
</tr>
<tr>
<td style="text-align:center">default + rest + spread</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">promises</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">math + number + string + array + object APIs</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">let + const</td>
<td style="text-align:center">★★★</td>
</tr>
<tr>
<td style="text-align:center">iterators + for..of</td>
<td style="text-align:center">★★</td>
</tr>
<tr>
<td style="text-align:center">tail calls</td>
<td style="text-align:center">★★</td>
</tr>
<tr>
<td style="text-align:center">modules</td>
<td style="text-align:center">★★</td>
</tr>
<tr>
<td style="text-align:center">map + set + weakmap + weakset</td>
<td style="text-align:center">★★</td>
</tr>
<tr>
<td style="text-align:center">generators</td>
<td style="text-align:center">★</td>
</tr>
<tr>
<td style="text-align:center">classes</td>
<td style="text-align:center">★</td>
</tr>
<tr>
<td style="text-align:center">binary and octal literals</td>
<td style="text-align:center">★</td>
</tr>
<tr>
<td style="text-align:center">symbols</td>
<td style="text-align:center">★</td>
</tr>
<tr>
<td style="text-align:center">module loaders</td>
<td style="text-align:center">☆</td>
</tr>
<tr>
<td style="text-align:center">proxies</td>
<td style="text-align:center">☆</td>
</tr>
<tr>
<td style="text-align:center">subclassable built-ins</td>
<td style="text-align:center">☆</td>
</tr>
<tr>
<td style="text-align:center">reflect api</td>
<td style="text-align:center">☆</td>
</tr>
<tr>
<td style="text-align:center">unicode</td>
<td style="text-align:center">☆</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="第二部分-ES6-的实用特性"><a href="#第二部分-ES6-的实用特性" class="headerlink" title="第二部分 ES6 的实用特性"></a>第二部分 ES6 的实用特性</h1><h2 id="一、使用-let-和-const"><a href="#一、使用-let-和-const" class="headerlink" title="一、使用 let 和 const"></a>一、使用 let 和 const</h2><p>let: 用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<p>const: 声明一个只读的常量。一旦声明，变量指向的那个内存地址不得改动。而且，<code>const</code>一旦声明变量，该变量就必须立即初始化，不能留到以后赋值。同样，声明的变量，只在<code>const</code>命令所在的代码块内有效。一般用<code>const</code>声明常亮。</p>
<h3 id="特点1：拥有块级作用域"><a href="#特点1：拥有块级作用域" class="headerlink" title="特点1：拥有块级作用域"></a>特点1：拥有块级作用域</h3><p><code>let</code>、<code>const</code>是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。但是在ES5中，块级作用域起不了任何作用。下面列举两种常见的错误场景，然后你会发现会用ES6是这么轻松的就避免犯错！</p>
<ul>
<li><p>第一种常见场景：内层变量可能会覆盖外层变量</p>
<pre><code>var a = 2
{
       var a = 1;
}
a // 1，一不小心发生了同名变量的覆盖

let a = 2
{
       let a = 1;
}
a // 2 ，es6通过块级作用域避免了覆盖的发生
</code></pre></li>
<li><p>第二种常见场景：用来计数的循环变量泄露为全局变量</p>
<pre><code>for(var i = 0; i &lt; 3; i++ ) {}
console.log(i);//3，可见，此处的 i 已然成为了全局变量

for(let i=0;i&lt;3;i++) {}
console.log(i);//使用ES6 抛出异常 ReferenceError: i is not defined
</code></pre></li>
</ul>
<h3 id="特点2：没有变量提升"><a href="#特点2：没有变量提升" class="headerlink" title="特点2：没有变量提升"></a>特点2：没有变量提升</h3><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。首先看一个看变量在同一个块作用域内的情况</p>
<pre><code>// 发生了变量提升
if(true) {
  console.log(x); // undefined
  var x = &apos;hello&apos;;
}

// 不准许在变量声明之前使用
if(true) {
  console.log(x); // ReferenceError
  let x = &apos;hello&apos;;
}
</code></pre><p>这个特性杜绝了我们日常编码中随处声明变量的恶习，强制要求我们养成提前声明变量的习惯。变量的声明和使用在同一作用域下如此，在不同作用域下更是如此：</p>
<pre><code>{{{{
      {
      	console.log(insane); // 报错，提前使用了变量
      }
      let insane = 'Hello World'
    }}}};

{{{{
    	let insane = 'Hello World'
      {
      	console.log(insane); // hello world
      }
    }}}};
</code></pre><h3 id="特点3：不允许在相同作用域内，重复声明同一个变量"><a href="#特点3：不允许在相同作用域内，重复声明同一个变量" class="headerlink" title="特点3：不允许在相同作用域内，重复声明同一个变量"></a>特点3：不允许在相同作用域内，重复声明同一个变量</h3><pre><code>// 正常
function () {
  var a = 10;
  var a = 1;
  // a ,1
}
// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}

function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
</code></pre><h2 id="二、解构赋值"><a href="#二、解构赋值" class="headerlink" title="二、解构赋值"></a>二、解构赋值</h2><p>ES6 允许按照一定模式，从数组、对象中提取值，对变量进行赋值，这被称为解构。如果等号的右边不是可遍历的结构，如 {}, undefined, 数字常量值等，那么将会报错。下面列举三种最常见的结构场景</p>
<h3 id="1-对象的解构赋值"><a href="#1-对象的解构赋值" class="headerlink" title="1. 对象的解构赋值"></a>1. 对象的解构赋值</h3><p>如果变量名与属性名(key)一致，则会对应的赋值，不论位置顺序</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;，即使顺序变了，还是赋值给了对应的key
</code></pre><p>如果变量名与属性名不一致，必须写成下面这样</p>
<pre><code>// 希望将对象中的foo属性赋值给变量baz
var { foo: baz } = { foo: &apos;aaa&apos;, bar: &apos;bbb&apos; };
baz // &quot;aaa&quot;
</code></pre><p>结构失败，则变量赋值为<code>undefined</code>  </p>
<pre><code>let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>究其原理，其实对象的解构赋值是下面形式的简写：</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };  
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。本段开始提到的<code>{foo}</code>其实是<code>{foo:foo}</code>的简写</p>
<p>在对象中使用解构赋值的好处很多，比如下文中，我们通过传递某个配置对象类完成某些赋值目的</p>
<pre><code>function init(options) {
      var id = options.uid;
      var cid = options.cid;
      var timeout = options.timeout;
      var protocol = options.protocol

      // code to init
}

var options = {
      id: &apos;101&apos;,
      cid: &apos;xxx&apos;,
      timeout: &apos;60&apos;,
      protocol: &apos;http&apos;
}

init(options)
</code></pre><p>这种方式实现起来很好，已经被许多JS开发者所采用。 只是我们必须看函数内部，才知道函数预期需要哪些参数。结合解构赋值，我们就可以在函数声明中清晰地表示这些参数：    </p>
<pre><code>function init(param, {id, cid, timeout, protocal}) {
    // code to init
}

var options = {
    id: &apos;101&apos;,
    cid: &apos;xxx&apos;,
    timeout: &apos;60&apos;,
    protocol: &apos;http&apos;
}

init(param, options)
</code></pre><p>在该函数中，我们没有传入一个配置对象，而是以对象解构赋值的方式，给它传参数。这样做不仅使这个函数更加简明，可读性也更高。</p>
<blockquote>
<p>注意如果函数调用时，参数被省略掉且没有设置默认值，则会抛出错误  </p>
</blockquote>
<p>函数解构和默认值组合使用的一个难点:再请问下面两种写法有什么差别？</p>
<pre><code>// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</code></pre><p>上面两种写法都对函数的参数设定了默认值，区别是：<br>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；<br>写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code>// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre><p>本质上来说，如果实参有值的话，参数的默认值就不会生效。如果参数的默认值不生效，那么解构就无法发生。</p>
<h3 id="2-数组的解构赋值"><a href="#2-数组的解构赋值" class="headerlink" title="2. 数组的解构赋值"></a>2. 数组的解构赋值</h3><pre><code>const arr = [1, 2, 3, 4];

// bad
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;
</code></pre><blockquote>
<p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值<br>和对象解构一样，如果解构不成功，变量的值就等于<code>undefined</code></p>
</blockquote>
<h3 id="3-函数返回值的解构"><a href="#3-函数返回值的解构" class="headerlink" title="3. 函数返回值的解构"></a>3. 函数返回值的解构</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>function getVal() {
  return [ 1, 2 ];
}

let [x,y] = getVal();//函数返回值的解构
console.log(x ,y);// 1, 2
</code></pre><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同或部分相同，左边的（部分）变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>// 嵌套
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

// ... 运算
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [head, ...tail, tailest] = [1, 2, 3, 4];
// SyntaxError: Rest element must be last element in array
</code></pre><h3 id="4-解构赋值使用默认值"><a href="#4-解构赋值使用默认值" class="headerlink" title="4. 解构赋值使用默认值"></a>4. 解构赋值使用默认值</h3><p>解构赋值允许指定默认值。ES6 内部使用严格相等运算符<code>===</code>，判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, &apos;undefined&apos;]; // x=&apos;a&apos;, y=&apos;undefined&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, null]; // x=&apos;a&apos;, y=null

var {x, y = 5} = {x: 1};
x // 1
y // 5
</code></pre><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError
</code></pre><h2 id="三、字符串扩展"><a href="#三、字符串扩展" class="headerlink" title="三、字符串扩展"></a>三、字符串扩展</h2><h3 id="1-模板文本"><a href="#1-模板文本" class="headerlink" title="1. 模板文本"></a>1. 模板文本</h3><p>模板字符串（template string）是增强版的字符串，用反引号（<code>）标识。它可以当作普通字符串使用，也可以用来定义多行字符串。在字符串中嵌入变量，需要将变量名写在</code>${}`之中。</p>
<p>首先，让我们看看 ES5 中拼接字符串的方式</p>
<pre><code>var name = &apos;feng&apos; , age = &apos;25&apos;;
var result = &apos;hello: &apos; + name + &apos;, your name is &apos; + age;
// hello: feng, your name is 25
</code></pre><p>再看看 ES6 的实现方式</p>
<pre><code>var name = &apos;feng&apos; , age = &apos;25&apos;;
var result = `hello: ${name}, your name is ${age}`
// hello: feng, your name is 25
</code></pre><p>模板中使用对象   </p>
<pre><code>let obj = {x:1,y:2};
console.log(`Your total is: ${obj.x + obj.y}`); // Your total is 3
</code></pre><p>模板中使用函数调用</p>
<pre><code>function fn() {
    return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
</code></pre><p>这样做省略了很多影响阅读的<code>+ ,</code>，直接在反引号中使用变量书写，很美观和便利！</p>
<h3 id="2-多行字符串"><a href="#2-多行字符串" class="headerlink" title="2. 多行字符串"></a>2. 多行字符串</h3><p>ES6 的多行字符串是一个非常实用的功能。在 ES5 中，我们不得不使用以下方法来表示多行字符串</p>
<pre><code>var multStr = &apos;Then took the other, as just as fair,\n\t&apos;
    + &apos;And having perhaps the better claim\n\t&apos;
    + &apos;Because it was grassy and wanted wear,\n\t&apos;
    + &apos;Though as for that the passing there\n\t&apos;
    + &apos;Had worn them really about the same,\n\t&apos;;
</code></pre><p>然而在 ES6 中，仅仅用反引号就可以解决了：</p>
<pre><code>var multStr = `Then took the other, as just as fair,
    And having perhaps the better claim
    Because it was grassy and wanted wear,
    Though as for that the passing there
    Had worn them really about the same,`;
</code></pre><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<pre><code>let tt = `
&lt;ul&gt;
    &lt;li&gt;first&lt;/li&gt;
    &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`;
console.log(tt)
</code></pre><p>输出成如下内容</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;first&lt;/li&gt;
    &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h2 id="四、函数扩展"><a href="#四、函数扩展" class="headerlink" title="四、函数扩展"></a>四、函数扩展</h2><h3 id="1-默认参数"><a href="#1-默认参数" class="headerlink" title="1. 默认参数"></a>1. 默认参数</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。项目中通过<code>||</code>来实现默认参数</p>
<pre><code>var link = function (height, color) {
    var height = height || 50;
    var color = color || &apos;red&apos;;
    console.log(height + &apos; : &apos; + color)
}

link();//50 red
link(10, &apos;blue&apos;);// 10 blue 1
</code></pre><p>目前来说是正常的，调用该函数时，没有传入实参，会用默认值。但是如果我们传入的参数本身会通过类型转换为<code>false</code>(比如<code>0</code> 或者<code>null</code>)就会有问题：系统忽略掉了我们的入参，反而使用了默认值！ </p>
<pre><code>link(0, &apos;blue&apos;);//50 blue
</code></pre><p>代码默认值是<code>50</code>，调用时希望设置为<code>0</code>，但是还是输出了默认值<code>50</code>。</p>
<p>在 ES6 中，我们通过如下方式来完成默认参数的设置，即直接写在参数定义的后面。我们甚至可以让默认值是一个函数（惰性求值）</p>
<pre><code>var link = function (height = 50, color = &apos;red&apos;) {
    console.log(height + &apos; : &apos; + color)
}

link(10, &apos;blue&apos;);//10: blue
link(0， blue);//0 blue
link();// 50 : red
</code></pre><p>还有一点需要着重介绍一下：默认参数可以和解构赋值默认值结合使用</p>
<pre><code>function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined, 5
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property &apos;x&apos; of undefined
</code></pre><p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值而生成。如果函数<code>foo</code>调用时参数不是对象（或者不能转换成对象），变量<code>x</code>和<code>y</code>就不会生成，从而报错。并且如果参数对象没有<code>y</code>属性，<code>y</code>的默认值<code>5</code>才会生效。</p>
<p>请注意上面例子与下面两种写法的区别</p>
<pre><code>function foo({x=1, y = 5}) {
  console.log(x, y);
}
foo() // TypeError: Cannot match against &apos;undefined&apos; or &apos;null&apos;.解构失败

function foo({x=1, y = 5} = {}) {
  console.log(x, y);
}
foo() // 1 5  双重默认值：首先因为实参为空，所以函数参数默认值{}生效。然后才是解构赋值的默认值生效
</code></pre><h3 id="2-Rest-不定参数"><a href="#2-Rest-不定参数" class="headerlink" title="2. Rest 不定参数"></a>2. Rest 不定参数</h3><p>ES6 引入 <code>rest参数</code>（形式为<code>...变量名</code>），用于获取函数的多余参数，<code>rest参数</code>搭配的变量是一个数组，该变量将多余的参数放入数组中。用来取代额外的<code>arguments</code>对象了。</p>
<pre><code>// arguments变量的写法
function sortNumbers() {
    return Array.prototype.slice.call(arguments).sort();
}  
// rest参数的写法
let sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre><p>利用 <code>rest参数</code>，可以向该函数传入任意数目的参数。下面这个例子中，其中<code>…x</code>代表了所有传入<code>add</code>函数的参数。</p>
<pre><code>//将所有参数相加的函数
function add(...x){
   return x.reduce((m, n)=&gt; m + n);
} 
console.log(add(1,2,3));//输出：6
console.log(add(1,2,3,4,5));//输出：15                                              
</code></pre><blockquote>
<p><code>rest参数</code>中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。<br><code>rest参数</code>之后不能再有其他参数（即,只能是最后一个参数），否则会报错。<br>一个函数声明只能允许有一个 <code>rest参数</code></p>
</blockquote>
<h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h3><p>我们知道在JS中回调是经常的事，而一般回调又以匿名函数的形式出现，每次都需要写一个<code>function(){}</code>甚是繁琐。当引入箭头操作符<code>=&gt;</code>后可以方便地写回调了。</p>
<p>它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值。即， <code>Inputs =&gt; outputs</code>。</p>
<pre><code>let array = [1, 2, 3];

//传统写法
array.forEach(function(v) {
    console.log(v);
});

//ES6
//使用函数体形式
array.forEach(v =&gt; {
    console.log(v)
});
// 或者直接使用更简洁的表达式
array.forEach(v =&gt; console.log(v));    
</code></pre><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code>var f = () =&gt; 5;
var sum = (num1, num2) =&gt; num1 + num2;
</code></pre><p>除了上面的写法的改变，剪头函数使用<code>this</code>时也和我们以前大不相同：以前我们使用闭包，<code>this</code>总是预期之外地产生改变。而箭头函数的迷人之处在于，<code>this</code>的指向是固定的。身处箭头函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>举个例子，实现一个功能，点击某个按钮之后，调用当前模块的<code>sendData()</code>方法：</p>
<p>首先看看ES5中的处理方式</p>
<pre><code>var polyglot = {
    name : &quot;feng&quot;,
    fruits : [&quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;],
    introduce : function () {
        const self = this;
        this.fruits.forEach(function(item) {
            console.log(this)
            console.log(&quot;My name is &quot; + self.name + &quot;, I eat &quot; + item + &quot;.&quot;);
        });
    }
}

polyglot.introduce();
</code></pre><p>在<code>introduce</code>里, <code>this.name</code>是<code>undefined</code>(浏览器环境中<code>forEach</code>的匿名回调中<code>this</code>指向<code>window</code>)。在回调函数外面，也就是<code>forEach</code>中， 它指向了<code>polyglot</code>对象。在这种情形下我们总是希望在函数内部<code>this</code>和函数外部的<code>this</code>指向同一个对象。在ES6中就不需要用 <code>_this = this</code>完成这个需求</p>
<pre><code>let polyglot = {
    name : &quot;feng&quot;,
    fruits : [&quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;],
    introduce : function () {
        this.fruits.forEach((item) =&gt; {
            console.log(&quot;My name is &quot; + this.name + &quot;, I eat &quot; + item + &quot;.&quot;);
        });
    }
}
</code></pre><p>再看个例子，来验证一下(需在浏览器环境验证)</p>
<pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log(&apos;id:&apos;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
</code></pre><p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到<code>100</code>毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code></p>
<p>本质上来说，<code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数</p>
<blockquote>
<p>1.简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。而且如果箭头函数有多个参数，必须用圆括号包裹<br>2.不可以使用<code>arguments</code>对象，该对象在函数体内不存在，外层函数的对应变量<br>3.由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向</p>
</blockquote>
<h2 id="五、数组扩展"><a href="#五、数组扩展" class="headerlink" title="五、数组扩展"></a>五、数组扩展</h2><h3 id="1-扩展运算符…"><a href="#1-扩展运算符…" class="headerlink" title="1. 扩展运算符…"></a>1. 扩展运算符…</h3><p>扩展运算符（spread）是三个点（…），它好比 <code>rest参数</code>的逆运算。<code>rest参数</code>将一个参数转换成数组，而本文中的扩展运算符则负责将一个数组转为用逗号分隔的参数序列。</p>
<pre><code>...[1, 2, 3]
// 1 2 3
1, ...[2, 3, 4], 5
// 1 2 3 4 5
[...document.querySelectorAll(&apos;div&apos;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]

var arr1 = [&apos;a&apos;, &apos;b&apos;];
var arr2 = [&apos;c&apos;];
[...arr1, ...arr2]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
</code></pre><p>下面看几个实际使用案例</p>
<ul>
<li><p>使用扩展运算符拷贝数组</p>
<pre><code>// bad
const len = items.length;
const itemsCopy = [];
let i;

for (i = 0; i &lt; len; i++) {
 itemsCopy[i] = items[i];
}

// good
const itemsCopy = [...items];
</code></pre></li>
<li><p>替代数组的 <code>apply</code>方法<br>原来在ES5中，因为方法或者函数不支持数组参数, 如<code>Math.max/Array.push()</code>,而必须使用<code>apply(array)</code>的场景，都可以直接使用扩展运算符 …</p>
<pre><code>// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f(...args);

var myArray = [1, 2, 3, 4];
Math.max(myArray); //error
Math.max.apply(Math, myArray);// 4，ES5写法
Math.max(...myArray);//4,ES6写法
</code></pre></li>
</ul>
<ul>
<li><p>与解构赋值结合</p>
<pre><code>let test = [1,2,3]
let [a, ...rest] = test;
a //1
</code></pre></li>
</ul>
<blockquote>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
</blockquote>
<h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from"></a>2. Array.from</h3><p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<pre><code>let arrayLike = {
    &apos;0&apos;: &apos;a&apos;,
    &apos;1&apos;: &apos;b&apos;,
    &apos;2&apos;: &apos;c&apos;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
</code></pre><p>还有，在查找一组DOM节点时</p>
<pre><code>const foo = document.querySelectorAll(&apos;.foo&apos;);
const nodes = Array.from(foo);
</code></pre><p>还有，上文说过使用<code>rest参数</code>将参数转换成数组，从而避免使用<code>arguments</code>对象。因为<code>arguments</code>是类数组对象，所以还可以通过<code>Array.from</code>来完成转换工作。</p>
<pre><code>function foo() {
  var args = Array.from(arguments);
  // ...
}
</code></pre><p><code>Array.from</code>的第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code>Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]


Array.from({ length: 2 }, () =&gt; &apos;jack&apos;)
// [&apos;jack&apos;, &apos;jack&apos;]
</code></pre><blockquote>
<p>类数组对象本质特征只有一点：任何有<code>length</code>属性的对象。<br><code>Array.from({ length: 3 });// [ undefined, undefined, undefined ]</code></p>
</blockquote>
<h3 id="3-fill"><a href="#3-fill" class="headerlink" title="3. fill"></a>3. fill</h3><p><code>fill</code>方法使用给定值，填充一个数组。该方法用于空数组的初始化非常方便。要注意，数组中已有的元素，会被全部抹去。</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre><h2 id="六、对象扩展"><a href="#六、对象扩展" class="headerlink" title="六、对象扩展"></a>六、对象扩展</h2><h3 id="1-对象属性的简写"><a href="#1-对象属性的简写" class="headerlink" title="1. 对象属性的简写"></a>1. 对象属性的简写</h3><p>如果对象的键值和变量名是一致的，ES6允许仅用变量名来初始化这个对象，而不是定义冗余的键值对。这时，属性名为变量名, 属性值为变量的值</p>
<pre><code>var foo = &apos;foo&apos;;
var bar = &apos;bar&apos;;
var baz = {
    foo,
    bar
};
// 等同于
var baz = {
    foo: foo,
    bar: bar
};
</code></pre><h3 id="2-对象方法的简写"><a href="#2-对象方法的简写" class="headerlink" title="2 对象方法的简写"></a>2 对象方法的简写</h3><pre><code>var o = {
  method(name) {
    return &quot;Hello!&quot; + name;
  }
};

// 等同于
var o = {
  method: function(name) {
    return &quot;Hello!&quot; + name;
  }
};
</code></pre><h3 id="3-对象导出属性的简写"><a href="#3-对象导出属性的简写" class="headerlink" title="3. 对象导出属性的简写"></a>3. 对象导出属性的简写</h3><pre><code>module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</code></pre><h3 id="4-新增：object-assign"><a href="#4-新增：object-assign" class="headerlink" title="4 新增：object.assign()"></a>4 新增：object.assign()</h3><p>用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。方法的第一个参数是目标对象，后面的参数都是源对象。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code>var target = { a: 1, b: 1 };
var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p>需要注意的是，这个方法施行的不是类似<code>merge</code>的操作，而是简单的同名<code>key</code>的的简单覆盖,而不是添加</p>
<pre><code>var target = { 
    a: 1, 
    b: {
        key: {
            inner_key:0
        }
    }
};
var source1 = { 
    b: {
        key:{
            inner_key:1,
            inner_key2:2,
            inner_key3:3
        }
    } 
};

Object.assign(target, source1);
// target { a: 1, b: { key: { inner_key: 1, inner_key2: 2, inner_key3: 3 } } }
</code></pre><blockquote>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
</blockquote>
<h3 id="5-Object-setPrototypeOf"><a href="#5-Object-setPrototypeOf" class="headerlink" title="5. Object.setPrototypeOf"></a>5. Object.setPrototypeOf</h3><p>用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<pre><code>Object.setPrototypeOf(object, prototype)
</code></pre><p>举一个例子</p>
<pre><code>let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto); // 将proto对象设置为obj的原型

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre><h3 id="6-Object-getPrototypeOf"><a href="#6-Object-getPrototypeOf" class="headerlink" title="6. Object.getPrototypeOf"></a>6. Object.getPrototypeOf</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。下面是一个例子。</p>
<pre><code>function Rectangle() {
  // ...
}

var rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre><h3 id="7-Object-keys-，Object-values-，Object-entries"><a href="#7-Object-keys-，Object-values-，Object-entries" class="headerlink" title="7. Object.keys()，Object.values()，Object.entries()"></a>7. Object.keys()，Object.values()，Object.entries()</h3><p><code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code>let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]
}
</code></pre><h2 id="七、Classes"><a href="#七、Classes" class="headerlink" title="七、Classes"></a>七、Classes</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<pre><code>function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;
};

var p = new Point(1, 2);
</code></pre><p>ES6 提供了更接近传统面相对象语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>
<pre><code>//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  // 方法之间不需要逗号分隔，加了会报错
  toString() {
    return `${this.x}{this.y}`
  }
}
</code></pre><blockquote>
<p>类必须使用<code>new</code>调用，否则会报错。</p>
</blockquote>
<h3 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h3><p>所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code>class Foo {
  static classMethod() {
    return &apos;hello&apos;;
  }
}

Foo.classMethod() // &apos;hello&apos;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre><blockquote>
<p>父类的静态方法，可以被子类继承</p>
</blockquote>
<h3 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h3><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code>class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    // 调用父类的 constructor(x, y) 
    // 相当于Point.prototype.constructor.call(this,x,y)
    super(x, y); 
    this.color = color;
  }

  toString() {
    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()
  }
}
</code></pre><p><code>super</code>关键字，它在这里表示父类的构造函数。子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。而 ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（<code>super()</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
<p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<pre><code>Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre><h2 id="八、Modules（模块）"><a href="#八、Modules（模块）" class="headerlink" title="八、Modules（模块）"></a>八、Modules（模块）</h2><h3 id="使用-import-取代-require"><a href="#使用-import-取代-require" class="headerlink" title="使用 import 取代 require"></a>使用 import 取代 require</h3><pre><code>// bad
const moduleA = require(&apos;moduleA&apos;);
const func1 = moduleA.func1;
const func2 = moduleA.func2;

// good
import { func1, func2 } from &apos;moduleA&apos;;
</code></pre><h3 id="使用-export-取代-module-exports"><a href="#使用-export-取代-module-exports" class="headerlink" title="使用 export 取代 module.exports"></a>使用 export 取代 module.exports</h3><pre><code>// point.js
module &quot;point&quot; {
    export class Point {
        constructor (x, y) {
            public x = x;
            public y = y;
        }
    }
}

// myapp.js
//声明引用的模块
module point from &quot;/point.js&quot;;
//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入
import Point from &quot;point&quot;;

var origin = new Point(0, 0);
console.log(origin);
</code></pre><hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/airbnb/javascript#ecmascript-6-es-2015-styles" target="_blank" rel="external">ES6编程规范</a><br><a href="https://qiutc.me/post/es6-cheatsheet.html#tip" target="_blank" rel="external">ES手册传送门</a></p>
<p><img src="/images/image1.png" alt="upload successful"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/11/webpack体积优化/" rel="next" title="webpack体积优化">
                <i class="fa fa-chevron-left"></i> webpack体积优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/11/Untitled/" rel="prev" title="ElastAlert日志监控预警">
                ElastAlert日志监控预警 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="jinhui-mobile">
          <p class="site-author-name" itemprop="name">jinhui-mobile</p>
           
              <p class="site-description motion-element" itemprop="description">stay hungry stay foolish</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jhmobile/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一部分：前言"><span class="nav-number">1.</span> <span class="nav-text">第一部分：前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、为什么要使用-ES6"><span class="nav-number">1.1.</span> <span class="nav-text">一、为什么要使用 ES6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Nodejs各版本对应的ES6支持情况"><span class="nav-number">1.2.</span> <span class="nav-text">二、Nodejs各版本对应的ES6支持情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、实用特性使用情况"><span class="nav-number">1.3.</span> <span class="nav-text">三、实用特性使用情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二部分-ES6-的实用特性"><span class="nav-number">2.</span> <span class="nav-text">第二部分 ES6 的实用特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、使用-let-和-const"><span class="nav-number">2.1.</span> <span class="nav-text">一、使用 let 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点1：拥有块级作用域"><span class="nav-number">2.1.1.</span> <span class="nav-text">特点1：拥有块级作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点2：没有变量提升"><span class="nav-number">2.1.2.</span> <span class="nav-text">特点2：没有变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点3：不允许在相同作用域内，重复声明同一个变量"><span class="nav-number">2.1.3.</span> <span class="nav-text">特点3：不允许在相同作用域内，重复声明同一个变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、解构赋值"><span class="nav-number">2.2.</span> <span class="nav-text">二、解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-对象的解构赋值"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 对象的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数组的解构赋值"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 数组的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-函数返回值的解构"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 函数返回值的解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-解构赋值使用默认值"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 解构赋值使用默认值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、字符串扩展"><span class="nav-number">2.3.</span> <span class="nav-text">三、字符串扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-模板文本"><span class="nav-number">2.3.1.</span> <span class="nav-text">1. 模板文本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-多行字符串"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 多行字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、函数扩展"><span class="nav-number">2.4.</span> <span class="nav-text">四、函数扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-默认参数"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. 默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Rest-不定参数"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. Rest 不定参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-箭头函数"><span class="nav-number">2.4.3.</span> <span class="nav-text">3. 箭头函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、数组扩展"><span class="nav-number">2.5.</span> <span class="nav-text">五、数组扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-扩展运算符…"><span class="nav-number">2.5.1.</span> <span class="nav-text">1. 扩展运算符…</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Array-from"><span class="nav-number">2.5.2.</span> <span class="nav-text">2. Array.from</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-fill"><span class="nav-number">2.5.3.</span> <span class="nav-text">3. fill</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、对象扩展"><span class="nav-number">2.6.</span> <span class="nav-text">六、对象扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-对象属性的简写"><span class="nav-number">2.6.1.</span> <span class="nav-text">1. 对象属性的简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对象方法的简写"><span class="nav-number">2.6.2.</span> <span class="nav-text">2 对象方法的简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-对象导出属性的简写"><span class="nav-number">2.6.3.</span> <span class="nav-text">3. 对象导出属性的简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-新增：object-assign"><span class="nav-number">2.6.4.</span> <span class="nav-text">4 新增：object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Object-setPrototypeOf"><span class="nav-number">2.6.5.</span> <span class="nav-text">5. Object.setPrototypeOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Object-getPrototypeOf"><span class="nav-number">2.6.6.</span> <span class="nav-text">6. Object.getPrototypeOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Object-keys-，Object-values-，Object-entries"><span class="nav-number">2.6.7.</span> <span class="nav-text">7. Object.keys()，Object.values()，Object.entries()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、Classes"><span class="nav-number">2.7.</span> <span class="nav-text">七、Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的静态方法"><span class="nav-number">2.7.1.</span> <span class="nav-text">类的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class的继承"><span class="nav-number">2.7.2.</span> <span class="nav-text">Class的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Modules（模块）"><span class="nav-number">2.8.</span> <span class="nav-text">八、Modules（模块）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-import-取代-require"><span class="nav-number">2.8.1.</span> <span class="nav-text">使用 import 取代 require</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-export-取代-module-exports"><span class="nav-number">2.8.2.</span> <span class="nav-text">使用 export 取代 module.exports</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章"><span class="nav-number">2.9.</span> <span class="nav-text">参考文章</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jinhui-mobile</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
